#!groovy
def baseUrl=BASE_URL // pulled from Jenkins
// Define variables for the pipeline usage
def sonarLogin, sonarPassword
def APPLICATION_BUILD_NAME, APP_VERSION, SELENIUM_HUB, APPLICATION_URL_DEV, DOCKER_IMAGE, REPO_OWNER, REPO_DEPLOY
REPO_OWNER="REI-Systems"
REPO_DEPLOY="REISystems-OGST-GSA-PPMS-UI-DEPLOY"
SELENIUM_HUB = "https://selenium-hub.${baseUrl}/wd/hub"
APPLICATION_URL_DEV = "https://ppms-app-ui.${baseUrl}"
APPLICATION_BUILD_NAME = "ppms-app-ui"
APP_VERSION = "develop"
pipeline {
    agent {
        kubernetes {
            yaml """
apiVersion: v1
kind: Pod
metadata:
  labels:
    some-label: node-build
spec:
  containers:
  # used to run maven processes
  - name: maven
    image: docker-registry.jfrog.mgmt-ppm.fcs.gsa.gov/maven:alpine
    command:
    - cat
    tty: true
    volumeMounts:
    - mountPath: /root/.m2
      name: maven-slave-pvc2
      readOnly: false
  # used to run node processes
  - name: node
    image: docker-registry.jfrog.mgmt-ppm.fcs.gsa.gov/node:14.15.4
    command:
    - cat
    tty: true
    volumeMounts:
    - mountPath: /root/npmcache
      name: node-slave-pvc2
      readOnly: false
  # used for unit tests
  - name: puppeteer
    image: docker-registry.jfrog.mgmt-ppm.fcs.gsa.gov/buildkite/puppeteer:latest
    command:
    - cat
    tty: true
  # used to run docker processes
  - name: docker
    image: docker-registry.jfrog.mgmt-ppm.fcs.gsa.gov/docker:latest
    command:
    - cat
    tty: true
    volumeMounts:
    - mountPath: /var/run/docker.sock
      name: docker-sock
  # used to run argocd/git processes
  - name: tools
    image: docker-registry.jfrog.mgmt-ppm.fcs.gsa.gov/argoproj/argo-cd-ci-builder:latest
    command:
    - cat
    tty: true
  - name: helm
    image: docker-registry.jfrog.mgmt-ppm.fcs.gsa.gov/lachlanevenson/k8s-helm:latest
    command:
    - cat
    tty: true
  - name: sonar
    image: docker-registry.jfrog.mgmt-ppm.fcs.gsa.gov/sonarsource/sonar-scanner-cli:latest
    command:
    - cat
    tty: true
  volumes:
  # use host docker
  - name: docker-sock
    hostPath:
      path: /var/run/docker.sock
  # cache node dependencies onto pvc between builds
  - name: node-slave-pvc2
    hostPath:
      path: /root/npmcache
  # cache maven dependencies onto pvc between builds
  - name: maven-slave-pvc2
    hostPath:
      path: /root/.m2
  imagePullSecrets:
  - jfrogcred
"""
        }
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '5', artifactNumToKeepStr: '5'))
        timeout(time: 2, unit: 'HOURS')
    }

    // Pipeline Stages start here
    // Requeres at least one stage
    stages {
        stage('Checkout SCM & Initialize') {
            steps {
                script {
                    container('node') {
                        checkout scm: scm
                        // Turn off Git's SSL cert check, uncomment if needed
                        // sh 'git config --global http.sslVerify false'
                        println("env.BRANCH_NAME:" + env.BRANCH_NAME)
                        println("env.GIT_COMMIT:" + env.GIT_COMMIT.substring(0, 6))
                        println("env.CHANGE_ID:" + env.CHANGE_ID)
                        // print out all environments
                        sh 'printenv'
                        sh "npm -v"
                        sh "node -v"

                        // setup application version and name if this branch requires app on demand
                        if (env.BRANCH_NAME.startsWith('feature-') || env.BRANCH_NAME == 'sprint-deploy' || env.BRANCH_NAME.startsWith('release-')) {
                            APP_VERSION = env.BRANCH_NAME.replaceAll('/', '')
                        } else if (env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) {
                            // get the feature branch name from different variable when this is a PR case and not a commit to the feature branch itself
                            APP_VERSION = env.CHANGE_BRANCH.replaceAll('/', '')
                        } else if (env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('release-') && env.CHANGE_TARGET.startsWith('master')) { // Production deployment
                            // get the feature branch name from different variable when this is a PR case and not a commit to the feature branch itself
                            APP_VERSION = env.CHANGE_BRANCH.replaceAll('/', '')
                        }

                        notifySlack('STARTED', APPLICATION_BUILD_NAME + ' ' + APP_VERSION + ' Job started!')
                    }
                }
            }
        }
        stage('install dependencies') {
            when {
                expression {
                    return ((env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) || env.BRANCH_NAME.startsWith('feature-') || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'sprint-deploy' || env.BRANCH_NAME.startsWith('release-'))
                }
            }
            steps {
                container('node'){
                    // Report back to github: Status Check PENDING
                    notifyGithubStatusCheck('PENDING', 'Continuous integration started!')

                    // Report back to github: Status Check PENDING
                    notifyGithubStatusCheck('PENDING', 'Continuous integration: Build the App!')

                    //sh 'ls node_modules'
                    sh 'ls /root/npmcache'
                    sh 'export PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=true'
                    sh 'npm install --prefer-offline --cache=/root/npmcache'
                }
            }
        }
        //Run Maven unit tests
        stage('Unit Test') {
            when {
                expression {
                    return ((env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) || env.BRANCH_NAME.startsWith('feature-') || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'sprint-deploy' || env.BRANCH_NAME.startsWith('release-'))
                }
            }
            steps {
                container('node'){
                    container('puppeteer'){
                        // Report back to github: Status Check PENDING
                        notifyGithubStatusCheck('PENDING', 'Continuous integration: Run unit test!')

                        // sh 'CI=true npm run test:headless'
                    }
                }
            }
            /*
            @TODO: Fix unit test and generate report & publish it
            post {
                always {
                    // publish  report
                    publishHTML(target: [
                        reportDir            : "./reports/coverage",
                        reportFiles          : 'index.html',
                        reportName           : 'Istanbul Report (Code Coverage)',
                        keepAll              : true,
                        alwaysLinkToLastBuild: true,
                        allowMissing         : false
                    ])

                }
            }
            */
        }

        stage('SonarQube Code Analysis') {
            when {
                expression {
                    return ((env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) || env.BRANCH_NAME.startsWith('feature-') || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'sprint-deploy' || env.BRANCH_NAME.startsWith('release-'))
                }
            }
            steps {
                // Report back to github: Status Check PENDING
                notifyGithubStatusCheck('PENDING', 'Continuous integration: Run code analysis!')

                script {
                    withCredentials([[$class: 'UsernamePasswordMultiBinding', credentialsId: "ldapCICD", passwordVariable: 'pass', usernameVariable: 'user']]) {
                        sonarLogin = '${user}'
                        sonarPassword = '${pass}'
                        // Run Sonar in this block would result into authorization issue. As the ${user} and ${pass} are encrypted ***** **** instead of plan values
                        container('sonar'){
                            // Create a new SonarQube analysis and dashboard for this new/updated feature branch / app
                            def additionalParams =  (env.BRANCH_NAME.startsWith('feature-') || env.BRANCH_NAME.startsWith('release-')) ? "" : ""

                            // Run Sonar in this block to ensure user/pass are not encrypted
                            sh "sonar-scanner -Dsonar.host.url=http://sonarqube-sonarqube:9000 -Dsonar.login=${user} -Dsonar.password=${pass} -Dsonar.projectKey=${APPLICATION_BUILD_NAME}-${APP_VERSION} -Dsonar.projectName=${APPLICATION_BUILD_NAME}-${APP_VERSION} -Dsonar.projectVersion=${env.GIT_COMMIT.substring(0, 6)} ${additionalParams}"
                        }
                    }
                }
            }
        }

        stage('Build and Deploy Image'){
            when {
                expression {
                    return (env.BRANCH_NAME.startsWith('feature-') || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'sprint-deploy' || env.BRANCH_NAME.startsWith('release-'))
                }
            }
            environment {
                GIT_CREDS = credentials('git')
            }
            steps{
                // Report back to github: Status Check PENDING
                notifyGithubStatusCheck('PENDING', 'Continuous integration: Build & Deploy image!')

                container('node'){
                    sh 'npm run build'
                    container('docker'){
                        script {
                            docker.withRegistry('https://docker-registry.jfrog.'+baseUrl, 'ldapCICD') {
                                DOCKER_IMAGE = docker.build("docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-${env.BUILD_NUMBER}", "--network=host -f ./Dockerfile-gsa .")
                                DOCKER_IMAGE.push()
                                // Always oush `latest` tag for either PR build or `master` build
                                if (env.BRANCH_NAME.startsWith('feature-')) {
                                    DOCKER_IMAGE.push("${APP_VERSION}-latest")
                                } else if(env.BRANCH_NAME == 'develop') {
                                    DOCKER_IMAGE.push("${APP_VERSION}")
                                } else if (env.BRANCH_NAME.startsWith('release-')) {
                                  // Uncomment for building `master` through PR
                                  //DOCKER_IMAGE.push("${APP_VERSION}-staging")
                                  DOCKER_IMAGE.push("release-staging") // Tag built image to staging Tag for production deployment
                                }
                            }

                            // Multi-branch workflow for Build and Tag Image based based on the env.BRANCH_NAME
                            if (env.BRANCH_NAME.startsWith('feature-')) {
                                container('tools') {
                                    sh "git clone https://$GIT_CREDS_USR:$GIT_CREDS_PSW@github.com/${REPO_OWNER}/${REPO_DEPLOY}.git"
                                    sh "git config --global user.email 'ci@ci.com'"

                                    dir("${REPO_DEPLOY}") {
                                        // check if this feature branch is new (first commit)
                                        if (!fileExists("./${APP_VERSION}/kustomization.yaml")) {
                                            sh "cp -rf ./feature ./${APP_VERSION}"
                                            sh "sed -i 's@__BRANCH_NAME__@${APP_VERSION}@' ./${APP_VERSION}/ingress.yaml" // rename the host URL for this newly feature App
                                            sh "sed -i 's@__BRANCH_NAME__@${APP_VERSION}@' ./${APP_VERSION}/deployment-patch.yaml" // rename the secret name to pull from for this newly feature App
                                            sh "git add ./${APP_VERSION}"
                                        }

                                        sh "cd ./${APP_VERSION} && kustomize edit set image docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-${env.BUILD_NUMBER} && kustomize edit set namesuffix -- -${APP_VERSION}"
                                        sh "git commit -am 'Publish new version' && git push || echo 'no changes'"

                                        try {
                                            sh "helm upgrade ${APPLICATION_BUILD_NAME}-${APP_VERSION} ./argocd-app --set branch.name=${APP_VERSION} --set destination.namespace=feature -n feature"
                                        } catch (Exception ex) {
                                            sh "helm install ${APPLICATION_BUILD_NAME}-${APP_VERSION} ./argocd-app --set branch.name=${APP_VERSION} --set destination.namespace=feature -n feature"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

      stage('Anchore Scan') {
        when {
          expression {
            return ((env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) || env.BRANCH_NAME.startsWith('feature-') || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'sprint-deploy' || env.BRANCH_NAME.startsWith('release-'))
          }
        }
        steps {
          script {
            def image = (env.BRANCH_NAME.startsWith('PR-') && (env.CHANGE_BRANCH.startsWith('feature-') || env.CHANGE_BRANCH.startsWith('sprint-deploy')) && env.CHANGE_TARGET.startsWith('develop')) ? "docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-latest" : "docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-${env.BUILD_NUMBER}"
            writeFile(text: image, file: 'anchore_images')
            anchore(name: 'anchore_images', bailOnFail: (env.BRANCH_NAME.startsWith('release-') || env.BRANCH_NAME == 'develop'), engineRetries: '600')
          }
        }
      }

        /*
        stage('Twistlock Scan & Publish') {
            when {
                expression {
                    return ((env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) || env.BRANCH_NAME.startsWith('feature-') || env.BRANCH_NAME == 'develop' || env.BRANCH_NAME == 'sprint-deploy')
                }
            }
            stages {
                stage('Twistlock Scan') {
                    steps {
                        script {
                            def imageTag = (env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) ? "${APP_VERSION}-latest" : "${APP_VERSION}-${env.BUILD_NUMBER}"
                            prismaCloudScanImage ca: '',
                                cert: '',
                                policy: 'warn',
                                compliancePolicy: 'critical',
                                containerized: true,
                                dockerAddress: 'unix:///var/run/docker.sock',
                                gracePeriodDays: 0,
                                ignoreImageBuildTime: true,
                                key: '',
                                logLevel: 'true',
                                requirePackageUpdate: false,
                                timeout: 10,
                                resultsFile: 'prisma-cloud-scan-results.json',
                                repository: "docker-registry.jfrog.${baseUrl}",
                                tag: "${imageTag}",
                                image: "${APPLICATION_BUILD_NAME}:${imageTag}"
                            // Identify the namespace where the image was pushed to based on the commit branch.

                        }

                    }
                }

                stage('Twistlock Publish') {
                    steps {
                        script {
                            def imageTag = (env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) ? "${APP_VERSION}-latest" : "${APP_VERSION}-${env.BUILD_NUMBER}"

                            prismaCloudPublish resultsFilePattern: 'prisma-cloud-scan-results.json'
                        }
                    }
                }
            }
        }
        */
        stage('Promote from Build to Dev') {
            when {
                expression {
                    return env.BRANCH_NAME == 'sprint-deploy'
                }
            }
            environment {
                GIT_CREDS = credentials('git')
            }
            steps {
                container('tools') {
                    sh "git clone https://$GIT_CREDS_USR:$GIT_CREDS_PSW@github.com/${REPO_OWNER}/${REPO_DEPLOY}.git"
                    sh "git config --global user.email 'ci@ci.com'"

                    dir("${REPO_DEPLOY}") {
                        sh "cd ./develop && kustomize edit set image docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-${env.BUILD_NUMBER}"
                        sh "git commit -am 'Publish new version `${APP_VERSION}-${env.BUILD_NUMBER}` to dev environment' && git push || echo 'no changes'"
                    }
                }
            }
        }

        stage('Running Serenity/Selenium Tests') {
            when {
                expression {
                    return  env.BRANCH_NAME == 'sprint-deploy'

                }
            }
            steps {
                container('tools') {
                    script {

                        sh "mkdir acceptance-tests"
                        sh "chmod 777 acceptance-tests"

                        // checkout acceptance tests repo to acceptance-tests dir in the current workspace
                        checkout([$class                           : 'GitSCM',
                                  branches                         : [[name: '*/develop']],
                                  doGenerateSubmoduleConfigurations: false,
                                  extensions                       : [[
                                                                          $class           : 'RelativeTargetDirectory',
                                                                          relativeTargetDir: 'acceptance-tests'
                                                                      ]],
                                  submoduleCfg                     : [],
                                  userRemoteConfigs                : [[
                                                                          url          : 'https://github.com/REI-Systems/REISystems-OGST-GSA-PPMS-TEST.git',
                                                                          credentialsId: 'git'
                                                                      ]]
                        ])

                        container ('maven'){
                            // run acceptance tests
                            // @TODO: fix selenium test and uncomment stage
                            //sh "cd acceptance-tests && mvn clean verify serenity:aggregate -Dwebdriver.driver=remote -Dwebdriver.remote.driver=chrome -Dwebdriver.remote.url=${SELENIUM_HUB} -Dwebdriver.base.url=${APPLICATION_URL_DEV} -Dserenity.proxy.http=0.0.0.0 -Dserenity.proxy.http_port=8080"
                        }
                        // public report
                        // @TODO: fix selenium test and uncomment stage
                        // publishHTML([allowMissing: false, alwaysLinkToLastBuild: true, keepAll: true, reportDir: 'acceptance-tests/target/site/serenity/', reportFiles: 'index.html', reportName: 'Integration Test Report', reportTitles: 'PPMS Tests'])

                        //publish 508 compliance report files
                        //zip zipFile: 'AccessibilityReport.zip', archive: true, dir: 'acceptance-tests/target/AccessibilityReport/'
                        // @TODO: fix selenium test and uncomment stage
                        //archiveArtifacts allowEmptyArchive: true, artifacts: 'acceptance-tests/target/AccessibilityReport/*.txt', onlyIfSuccessful: false, fingerprint: true
                    }
                }
            }
        }

        stage('Promote from Dev to Test') {
            when {
                expression {
                    return env.BRANCH_NAME == 'sprint-deploy'
                }
            }
            environment {
                GIT_CREDS = credentials('git')
            }
            steps {
                container('tools') {
                    dir("${REPO_DEPLOY}") {
                        sh "cd ./test && kustomize edit set image docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-${env.BUILD_NUMBER}"
                        sh "git commit -am 'Publish new version `${APP_VERSION}-${env.BUILD_NUMBER}` to test environment' && git push || echo 'no changes'"
                    }
                }
            }
        }

        stage('Promotion gate (UAT)') {
            when {
                expression {
                    return env.BRANCH_NAME == 'develop'
                }
            }
            steps {
                script {
                    input message: 'Promote application to UAT?'
                }
            }
        }

        stage('Promote from Test to UAT') {
            when {
                expression {
                    return env.BRANCH_NAME == 'develop'
                }
            }
            environment {
                GIT_CREDS = credentials('git')
            }
            steps {
                container('tools') {
                    sh "git clone https://$GIT_CREDS_USR:$GIT_CREDS_PSW@github.com/${REPO_OWNER}/${REPO_DEPLOY}.git"
                    sh "git config --global user.email 'ci@ci.com'"
                    dir("${REPO_DEPLOY}") {
                        sh "cd ./uat && kustomize edit set image docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-${env.BUILD_NUMBER}"
                        sh "git commit -am 'Publish new version `${APP_VERSION}-${env.BUILD_NUMBER}` to UAT environment' && git push || echo 'no changes'"
                    }
                }
            }
        }

          stage('Promotion gate (Staging)') {
              when {
                  expression {
                      return env.BRANCH_NAME.startsWith('release-')
                  }
              }
              steps {
                  script {
                      input message: "Promote this release (${APPLICATION_BUILD_NAME}:${APP_VERSION}-${env.BUILD_NUMBER}) to Staging?"
                  }
              }
          }

          stage('Promote from release to Staging') {
              when {
                  expression {
                      return env.BRANCH_NAME.startsWith('release-')
                  }
              }
              environment {
                  GIT_CREDS = credentials('git')
              }
              steps {
                  container('tools') {
                      sh "git clone https://$GIT_CREDS_USR:$GIT_CREDS_PSW@github.com/${REPO_OWNER}/${REPO_DEPLOY}.git"
                      sh "git config --global user.email 'ci@ci.com'"

                      dir("${REPO_DEPLOY}") {
                          sh "cd ./staging && kustomize edit set image docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-${env.BUILD_NUMBER}"
                          sh "git commit -am 'Publish new version `${APP_VERSION}-${env.BUILD_NUMBER}` to staging environment' && git push || echo 'no changes'"
                      }
                  }
              }
          }

          stage('Promotion gate (Production)') {
              when {
                  expression {
                    // Uncomment for building `master` through PR
                    //return (env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('release-') && env.CHANGE_TARGET.startsWith('master'))
                    return env.BRANCH_NAME == 'master'
                  }
              }
              steps {
                  script {
                    // Uncomment for building `master` through PR
                    //input message: "Promote this release (${APPLICATION_BUILD_NAME}:${APP_VERSION}-staging) to Production?"
                    input message: "Promote to Production?"
                  }
              }
          }

        stage('Promote from Stage to Prod') {
            when {
                expression {
                  // Uncomment for building `master` through PR
                  //return (env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('release-') && env.CHANGE_TARGET.startsWith('master'))
                  return env.BRANCH_NAME == 'master'
                }
            }
            environment {
                GIT_CREDS = credentials('git')
            }
            steps {
                container('docker') {
                    script {
                      // Uncomment for building `master` through PR
                      //def imageTag = "master-${APP_VERSION}-${env.BUILD_NUMBER}"
                      def imageTag = "master-${env.BUILD_NUMBER}"
                        docker.withRegistry('https://docker-registry.jfrog.' + baseUrl, 'jfrog') {
                          // Pull APP_VERSION=`release-*` image tagged through `release` branch pipeline when a PR get's opened up against `master`
                          // Uncomment for building `master` through PR
                          //DOCKER_IMAGE = docker.image("docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${APP_VERSION}-staging")
                          DOCKER_IMAGE = docker.image("docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:release-staging")
                            DOCKER_IMAGE.pull()
                            DOCKER_IMAGE.push("${imageTag}")
                        }

                        container('tools') {
                            sh "git clone https://$GIT_CREDS_USR:$GIT_CREDS_PSW@github.com/${REPO_OWNER}/${REPO_DEPLOY}.git"
                            sh "git config --global user.email 'ci@ci.com'"

                            dir("${REPO_DEPLOY}") {
                                sh "cd ./prod && kustomize edit set image docker-registry.jfrog.${baseUrl}/${APPLICATION_BUILD_NAME}:${imageTag}"
                                sh "git commit -am 'Publish new version `${imageTag}` to prod environment' && git push || echo 'no changes'"
                            }
                        }
                    }
                }
            }
        }
    }

    post {
        always {
            echo 'This will always run'
        }
        success {
            echo 'This will run only if successful'
            notifySlack('SUCCESS', 'Job successfully finished!')

            // Report back to github: Status Check to enable the PR for merge
            notifyGithubStatusCheck('SUCCESS', 'Continuous integration succeeded!')
        }
        failure {
            echo 'This will run only if failed'
            notifySlack('FAILED', 'Job failed!')

            // Report back to github: Status Check to disable the PR for merge
            notifyGithubStatusCheck('FAILURE', 'Continuous integration failed!')
        }
        unstable {
            echo 'This will run only if the run was marked as unstable'
            notifySlack('UNSTABLE', 'Job unstable!')
        }
        changed {
            echo 'This will run only if the state of the Pipeline has changed'
            echo 'For example, if the Pipeline was previously failing but is now successful'
        }
    }
}

def notifySlack(String buildStatus = 'STARTED', additionalMessage = null) {
    // Build status of null means success.
    buildStatus = buildStatus ?: 'SUCCESS'

    def color

    if (buildStatus == 'STARTED') {
        color = '#D4DADF'
    } else if (buildStatus == 'SUCCESS') {
        color = '#BDFFC3'
    } else if (buildStatus == 'UNSTABLE') {
        color = '#FFFE89'
    } else {
        color = '#FF9FA1'
    }

    def msg = "${buildStatus}: `${env.JOB_NAME}` #${env.BUILD_NUMBER}:\n${env.BUILD_URL}\n${additionalMessage}"

    slackSend(color: color, message: msg)
}

// Report back to github: Status Check to enable or disable the PR for merge
def notifyGithubStatusCheck(String status = 'SUCCESS', String description) {
    if (env.BRANCH_NAME.startsWith('PR-') && env.CHANGE_BRANCH.startsWith('feature-') && env.CHANGE_TARGET.startsWith('develop')) {
        // https://jenkins.io/doc/pipeline/steps/pipeline-githubnotify-step/
        // https://developer.github.com/v3/repos/statuses/
        // Report back to github: Status Check to enable the PR for merge
        githubNotify description: description,  status: status, context: 'continuous-integration/jenkins/pr-head'
    }
}
